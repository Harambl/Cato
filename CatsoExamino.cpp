class Solution {
public:
    int splitArray(vector<int>& nums, int k) {
        int l = *max_element(nums.begin(), nums.end());  // левая граница - максимальный член массива
        int r = accumulate(nums.begin(), nums.end(), 0); // правая граница - сумма всего массива

        auto check = [&](int m) -> bool {
            int count = 1; // кол-во подмассивов
            int sum = 0; // сумма в подмассиве
            for (int i = 0; i < nums.size(); i++) {
                if (sum + nums[i] > m) { // если больше m то 
                    count++; // идем в новый подмассив
                    sum = 0; // и сбрасываем сумму подмассива
                }
                sum += nums[i]; // продолжаем считать и идти по подмассиву
            }
            return count <= k; // возвращаем булевое значение от проверки на то сколько подмассивов удалось получить 
        };
        int ans = -1; // просто нач условие
        while (l <= r) { // пока левая граница не перешла правую
            int m = l + (r - l) / 2; // пробуем взять число которе может оказаться ответом (среднее между левой и правой)

            if (check(m)) { // проверяем можем ли найти с таким m удовлетворяющие условию подмассивы и суммы
                ans = m; // запоминаем
                r = m - 1; // но пробуем взять ещё меньше
            } else
                l = m + 1; // m слишком мал - попробуем увеличить
        }
        return ans;
    }
};
